<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"
    />
    <style>
      body {
        margin: 0;
      }
    </style>
  </head>
  <body>
    <script type="module">
      import * as THREE from 'https://threejs.org/build/three.module.js'

      import { STLLoader } from 'https://threejs.org/examples/jsm/loaders/STLLoader.js'

      const INJECTED_MODEL_DATA_GOES_HERE = undefined

      const model = INJECTED_MODEL_DATA_GOES_HERE || {
        name: 'Trophy HackEps',
        stlUrl: './assets/models/10-HackEps_Trofeu.stl',
        color: '#00ff00',
      }

      console.log(window.location)

      let container

      let camera
      let scene
      let renderer

      init()
      render()

      function init() {
        container = document.createElement('div')
        document.body.appendChild(container)

        camera = new THREE.PerspectiveCamera(
          100,
          window.innerWidth / window.innerHeight,
          1,
          15
        )
        camera.position.set(0, 0, 10)

        const cameraTarget = new THREE.Vector3(0, 0, 0)
        camera.lookAt(cameraTarget)

        scene = new THREE.Scene()
        scene.background = new THREE.Color(0xffffff)

        const loader = new STLLoader()

        loader.load(model.stlUrl, (geometry) => {
          const material = new THREE.MeshPhongMaterial({
            color: 0xff5533,
            specular: 0x111111,
            shininess: 200,
          })
          const mesh = new THREE.Mesh(geometry, material)
          mesh.geometry.center()
          mesh.geometry.computeBoundingBox()
          console.log(mesh.geometry.boundingBox)

          const scale =
            5 /
            Math.max(
              mesh.geometry.boundingBox.max.x,
              mesh.geometry.boundingBox.max.y,
              mesh.geometry.boundingBox.max.z
            )
          console.log(scale)
          mesh.position.set(0, 0, 0)
          mesh.rotation.set(0, 0, 0)
          mesh.scale.set(scale, scale, scale)

          mesh.castShadow = true
          mesh.receiveShadow = true

          scene.add(mesh)
          // scene.add(new THREE.BoxHelper(mesh, 0x000000))

          render()
        })

        // Lights
        scene.add(new THREE.HemisphereLight(0x443333, 0x111122))
        addShadowedLight(1, 1, 1, 0xffffff, 1.35)
        addShadowedLight(0.5, 1, -1, 0xffffff, 0.5)

        // renderer
        renderer = new THREE.WebGLRenderer({ antialias: true })
        renderer.setPixelRatio(window.devicePixelRatio)
        renderer.setSize(window.innerWidth, window.innerHeight)
        renderer.outputEncoding = THREE.sRGBEncoding
        renderer.shadowMap.enabled = true

        container.appendChild(renderer.domElement)
      }

      function addShadowedLight(x, y, z, color, intensity) {
        const directionalLight = new THREE.DirectionalLight(color, intensity)
        directionalLight.position.set(x, y, z)
        scene.add(directionalLight)

        directionalLight.castShadow = true

        const d = 1
        directionalLight.shadow.camera.left = -d
        directionalLight.shadow.camera.right = d
        directionalLight.shadow.camera.top = d
        directionalLight.shadow.camera.bottom = -d

        directionalLight.shadow.camera.near = 1
        directionalLight.shadow.camera.far = 4

        directionalLight.shadow.bias = -0.002
      }

      function render() {
        renderer.render(scene, camera)
      }
    </script>
  </body>
</html>
